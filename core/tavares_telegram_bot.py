import asyncio
import logging
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from telegram import Bot
from telegram.ext import Application, CommandHandler, ContextTypes
import time
import os

logger = logging.getLogger('TavaresTelegram')

class TavaresTelegramBot:
    """TAVARES A EVOLU√á√ÉO - Sistema completo de trading"""
    
    def __init__(self):
        # üî• VERIFICA√á√ÉO DE INST√ÇNCIA √öNICA
        self._instance_id = f"tavares_{int(time.time())}"
        logger.info(f"ü§ñ Inicializando TAVARES - ID: {self._instance_id}")
        
        # üß† Sistema Neural
        from cerebro.rede_neural_simples import CerebroNeuralSimples
        from cerebro.analise_sentimentos import AnalisadorSentimentos
        
        self.cerebro = CerebroNeuralSimples()
        self.analisador_sentimentos = AnalisadorSentimentos()
        
        # üí∞ Bybit Manager
        from core.exchange_manager import BybitManager
        self.bybit = BybitManager()
        
        # ü§ñ Telegram
        from core.config import config
        self.config = config
        self.bot = Bot(token=config.TELEGRAM_BOT_TOKEN)
        self.chat_id = config.TELEGRAM_CHAT_ID
        
        # üìä Estado do Sistema
        self.estado = {
            'id': self._instance_id,
            'status': 'üü¢ INICIANDO',
            'modo': 'BYBIT REAL üí∞',
            'ciclo_atual': 0,
            'ultima_atualizacao': datetime.now().isoformat(),
            'performance': {
                'total_ciclos': 0,
                'operacoes_executadas': 0,
                'operacoes_lucrativas': 0,
                'lucro_total': 0.0,
                'saldo_atual': self.bybit.obter_saldo(),
                'win_rate': 0.0
            },
            'sentimento_mercado': {},
            'historico_operacoes': [],
            'bybit_status': 'ONLINE' if not self.bybit.modo_offline else 'OFFLINE'
        }
        
        logger.info("ü§ñ TAVARES INICIALIZADO COM SUCESSO!")
        
    async def enviar_mensagem(self, texto):
        """Enviar mensagem para o Telegram"""
        try:
            await self.bot.send_message(
                chat_id=self.chat_id,
                text=texto,
                parse_mode='HTML'
            )
            logger.info(f"üì§ Mensagem enviada: {texto[:50]}...")
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar mensagem Telegram: {e}")
    
    async def enviar_operacao_real(self, operacao):
        """Enviar notifica√ß√£o de opera√ß√£o REAL"""
        sinal = operacao['sinal']
        resultado_real = operacao.get('resultado_real', {})
        
        emoji = "üü¢" if resultado_real.get('side') == 'buy' else "üî¥"
        seta = "üìà" if sinal['direcao'] == 'BUY' else "üìâ"
        
        mensagem = f"""
{emoji} <b>üî• OPERA√á√ÉO REAL EXECUTADA</b> {seta}

<b>Par:</b> {sinal['par']}
<b>Dire√ß√£o:</b> {sinal['direcao']}
<b>Confian√ßa:</b> {sinal['confianca']:.1f}%
<b>Valor:</b> ${self.config.VALOR_POR_TRADE}

<b>ID Ordem:</b> <code>{resultado_real.get('id', 'N/A')}</code>
<b>Pre√ßo:</b> ${resultado_real.get('price', 'N/A')}
<b>Quantidade:</b> {resultado_real.get('amount', 'N/A')}

<b>Saldo Atual:</b> ${self.estado['performance']['saldo_atual']:.2f}

‚è∞ <i>{datetime.now().strftime('%H:%M:%S')}</i>
        """
        
        await self.enviar_mensagem(mensagem)
    
    async def executar_operacao_real(self, previsao):
        """Executar opera√ß√£o REAL na Bybit"""
        try:
            logger.info(f"üí∞ EXECUTANDO OPERA√á√ÉO REAL: {previsao['par']} {previsao['direcao']}")
            
            # Verificar se Bybit est√° online
            if self.bybit.modo_offline:
                await self.enviar_mensagem(
                    f"üö´ <b>BYBIT OFFLINE</b>\n\n"
                    f"Opera√ß√£o {previsao['par']} {previsao['direcao']} cancelada.\n"
                    f"üí° <i>Configure VPS para opera√ß√£o real</i>"
                )
                return None
            
            # Verificar saldo
            saldo_atual = self.bybit.obter_saldo()
            if saldo_atual < self.config.VALOR_POR_TRADE:
                await self.enviar_mensagem(
                    f"‚ö†Ô∏è <b>SALDO INSUFICIENTE</b>\n\n"
                    f"Saldo: ${saldo_atual:.2f}\n"
                    f"Necess√°rio: ${self.config.VALOR_POR_TRADE}\n"
                    f"Opera√ß√£o cancelada."
                )
                return None
            
            # Executar ordem na Bybit
            resultado_ordem = await self.bybit.executar_ordem(
                previsao['par'], 
                previsao['direcao'], 
                self.config.VALOR_POR_TRADE
            )
            
            if resultado_ordem:
                # Registrar opera√ß√£o
                operacao = {
                    'id': f"TAVR{int(time.time())}",
                    'sinal': previsao,
                    'resultado_real': resultado_ordem,
                    'timestamp': datetime.now().isoformat(),
                    'tipo': 'REAL'
                }
                
                self.estado['historico_operacoes'].append(operacao)
                self.estado['performance']['operacoes_executadas'] += 1
                
                # Atualizar saldo
                self.estado['performance']['saldo_atual'] = self.bybit.obter_saldo()
                
                # Enviar notifica√ß√£o
                await self.enviar_operacao_real(operacao)
                
                return operacao
            else:
                await self.enviar_mensagem(
                    f"‚ùå <b>FALHA NA ORDEM REAL</b>\n\n"
                    f"Par: {previsao['par']}\n"
                    f"Erro: Ordem n√£o executada"
                )
                return None
                
        except Exception as e:
            logger.error(f"‚ùå ERRO OPERA√á√ÉO REAL: {e}")
            await self.enviar_mensagem(
                f"üí• <b>ERRO NA ORDEM</b>\n\n"
                f"Par: {previsao['par']}\n"
                f"Erro: {str(e)[:100]}..."
            )
            return None
    
    async def executar_ciclo_trading(self):
        """Executar ciclo completo de trading"""
        try:
            self.estado['ciclo_atual'] += 1
            self.estado['performance']['total_ciclos'] += 1
            
            logger.info(f"üîÆ CICLO {self.estado['ciclo_atual']} - TAVARES ANALISANDO...")
            
            # üîÑ ATUALIZAR STATUS BYBIT
            self.estado['bybit_status'] = 'ONLINE' if not self.bybit.modo_offline else 'OFFLINE'
            
            # 1. üì∞ AN√ÅLISE DE SENTIMENTOS
            await self._analisar_sentimentos_mercado()
            
            # 2. üìä COLETAR DADOS
            dados_mercado = await self._coletar_dados_reais()
            
            # 3. üéØ PREVIS√ÉO NEURAL
            previsoes = await self._gerar_previsoes_neurais(dados_mercado)
            
            # 4. ‚ö° EXECUTAR OPERA√á√ïES
            await self._executar_operacoes(previsoes)
            
            # 5. üìä ATUALIZAR ESTADO
            self.estado['status'] = 'üü¢ OPERANDO'
            self.estado['ultima_atualizacao'] = datetime.now().isoformat()
            
            # 6. üìã RELAT√ìRIO PERI√ìDICO
            if self.estado['ciclo_atual'] % 10 == 0:
                await self.enviar_relatorio_diario()
            
        except Exception as e:
            logger.error(f"‚ùå ERRO NO CICLO: {e}")
            self.estado['status'] = 'üî¥ ERRO TEMPOR√ÅRIO'
    
    async def _analisar_sentimentos_mercado(self):
        """Analisar sentimentos do mercado"""
        try:
            sentimento = self.analisador_sentimentos.analisar_sentimento_mercado()
            self.estado['sentimento_mercado'] = sentimento
            logger.info(f"üìä Sentimento: {sentimento.get('sentimento_geral', 'N/A')}")
        except Exception as e:
            logger.error(f"‚ùå Erro sentimentos: {e}")
            self.estado['sentimento_mercado'] = {
                'sentimento_geral': 'NEUTRO', 
                'score_medio': 0,
                'timestamp': datetime.now().isoformat()
            }
    
    async def _coletar_dados_reais(self):
        """Coletar dados do mercado"""
        try:
            dados = {}
            
            for par in self.config.PARES_MONITORADOS:
                try:
                    ohlcv = self.bybit.obter_dados_mercado(par, '15m', 50)
                    
                    if ohlcv:
                        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                        dados[par] = {'15m': df}
                        logger.debug(f"‚úÖ Dados coletados: {par}")
                    else:
                        logger.warning(f"‚ö†Ô∏è Dados vazios para {par}")
                        continue
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Erro ao coletar dados {par}: {e}")
                    continue
            
            return dados
            
        except Exception as e:
            logger.error(f"‚ùå Erro geral na coleta de dados: {e}")
            return {}
    
    async def _gerar_previsoes_neurais(self, dados_mercado):
        """Gerar previs√µes neurais"""
        previsoes = []
        
        for par in self.config.PARES_MONITORADOS:
            if par in dados_mercado:
                try:
                    # Criar dados espec√≠ficos para o par
                    dados_par = {par: dados_mercado[par]}
                    
                    # Gerar previs√£o
                    previsao = self.cerebro.prever(dados_par)
                    previsao['par'] = par
                    
                    previsoes.append(previsao)
                    logger.info(f"üéØ {par}: {previsao['direcao']} ({previsao['confianca']:.1f}%)")
                    
                except Exception as e:
                    logger.error(f"‚ùå Erro na previs√£o {par}: {e}")
                    continue
        
        return previsoes
    
    async def _executar_operacoes(self, previsoes):
        """Executar opera√ß√µes baseadas nas previs√µes"""
        try:
            for previsao in previsoes:
                # Crit√©rio conservador para opera√ß√µes
                if (previsao['confianca'] >= self.config.CONFIANCA_MINIMA and 
                    previsao['direcao'] != 'HOLD'):
                    
                    if not self.bybit.modo_offline:
                        # MODO REAL - Executar ordem
                        await self.executar_operacao_real(previsao)
                    else:
                        # MODO OFFLINE - Apenas registrar sinal
                        logger.info(f"üéØ SINAL (OFFLINE): {previsao['par']} {previsao['direcao']} ({previsao['confianca']:.1f}%)")
                    
                    await asyncio.sleep(2)  # Delay entre opera√ß√µes
                    
        except Exception as e:
            logger.error(f"‚ùå Erro na execu√ß√£o: {e}")
    
    async def enviar_relatorio_diario(self):
        """Enviar relat√≥rio di√°rio"""
        try:
            perf = self.estado['performance']
            sentimento = self.estado['sentimento_mercado']
            
            # Calcular win rate
            if perf['operacoes_executadas'] > 0:
                win_rate = (perf['operacoes_lucrativas'] / perf['operacoes_executadas']) * 100
            else:
                win_rate = 0
            
            status_bybit = "üü¢ ONLINE" if not self.bybit.modo_offline else "üî¥ OFFLINE"
            
            mensagem = f"""
üìä <b>RELAT√ìRIO TAVARES</b>

<b>Status Sistema:</b> {self.estado['status']}
<b>Status Bybit:</b> {status_bybit}
<b>Ciclos Executados:</b> {perf['total_ciclos']}
<b>Opera√ß√µes Realizadas:</b> {perf['operacoes_executadas']}
<b>Win Rate:</b> {win_rate:.1f}%
<b>Saldo Atual:</b> <b>${perf['saldo_atual']:.2f}</b>

<b>An√°lise de Mercado:</b>
‚Ä¢ Sentimento: {sentimento.get('sentimento_geral', 'N/A')}
‚Ä¢ Score: {sentimento.get('score_medio', 0):.3f}

üí™ <i>Sistema ativo e monitorando</i>
            """
            
            await self.enviar_mensagem(mensagem)
            
        except Exception as e:
            logger.error(f"‚ùå Erro no relat√≥rio: {e}")
    
    # COMANDOS TELEGRAM
    async def comando_start(self, update, context):
        """Comando /start"""
        status_bybit = "üü¢ CONECTADO" if not self.bybit.modo_offline else "üî¥ OFFLINE"
        
        mensagem = f"""
ü§ñ <b>TAVARES A EVOLU√á√ÉO</b> üöÄ

<b>Status Bybit:</b> {status_bybit}
<b>Modo:</b> OPERA√á√ÉO REAL
<b>Estrat√©gia:</b> Neural + An√°lise T√©cnica
<b>Risco:</b> 1% por trade

<b>Comandos Dispon√≠veis:</b>
/status - Status completo
/saldo - Saldo atual
/operacoes - Hist√≥rico
/performance - Performance
/sentimento - An√°lise de mercado

‚ö° <i>Sistema ativo e monitorando</i>
        """
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def comando_status(self, update, context):
        """Comando /status"""
        perf = self.estado['performance']
        sentimento = self.estado['sentimento_mercado']
        
        status_bybit = "üü¢ ONLINE" if not self.bybit.modo_offline else "üî¥ OFFLINE"
        
        mensagem = f"""
üí∞ <b>STATUS TAVARES</b>

<b>Sistema:</b> {self.estado['status']}
<b>Bybit:</b> {status_bybit}
<b>Ciclos:</b> {perf['total_ciclos']}
<b>Opera√ß√µes:</b> {perf['operacoes_executadas']}
<b>Saldo:</b> <code>${perf['saldo_atual']:.2f}</code>

<b>Mercado:</b>
‚Ä¢ Sentimento: {sentimento.get('sentimento_geral', 'N/A')}
‚Ä¢ Score: {sentimento.get('score_medio', 0):.3f}

üîÑ <i>√öltima atualiza√ß√£o: {self.estado['ultima_atualizacao'][11:19]}</i>
        """
        
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def comando_saldo(self, update, context):
        """Comando /saldo"""
        saldo = self.bybit.obter_saldo()
        status_bybit = "üü¢ ONLINE" if not self.bybit.modo_offline else "üî¥ OFFLINE"
        
        mensagem = f"""
üí∞ <b>SALDO BYBIT</b>

<b>Status:</b> {status_bybit}
<b>Saldo Dispon√≠vel:</b> <code>${saldo:.2f}</code>
<b>Valor por Trade:</b> <code>${self.config.VALOR_POR_TRADE}</code>
<b>Risco por Trade:</b> <code>{self.config.RISK_PER_TRADE*100}%</code>

üí∏ <i>Gest√£o conservadora ativa</i>
        """
        
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def comando_operacoes(self, update, context):
        """Comando /operacoes"""
        operacoes = self.estado['historico_operacoes'][-5:]
        
        if not operacoes:
            await update.message.reply_text("üì≠ Nenhuma opera√ß√£o executada ainda")
            return
        
        mensagem = "üìä <b>√öLTIMAS OPERA√á√ïES</b>\n\n"
        
        for op in reversed(operacoes):
            sinal = op['sinal']
            resultado = op.get('resultado_real', {})
            
            emoji = "üü¢" if resultado.get('side') == 'buy' else "üî¥"
            mensagem += f"""{emoji} <b>{sinal['par']}</b> {sinal['direcao']}
Conf: {sinal['confianca']:.1f}% | Pre√ßo: ${resultado.get('price', 'N/A')}
ID: <code>{resultado.get('id', 'N/A')}</code>
{op['timestamp'][11:19]}\n\n"""
        
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def comando_performance(self, update, context):
        """Comando /performance"""
        perf = self.estado['performance']
        
        if perf['operacoes_executadas'] > 0:
            win_rate = (perf['operacoes_lucrativas'] / perf['operacoes_executadas']) * 100
        else:
            win_rate = 0
        
        mensagem = f"""
üìà <b>PERFORMANCE TAVARES</b>

<b>Estat√≠sticas:</b>
‚Ä¢ Total Ciclos: {perf['total_ciclos']}
‚Ä¢ Opera√ß√µes: {perf['operacoes_executadas']}
‚Ä¢ Lucrativas: {perf['operacoes_lucrativas']}
‚Ä¢ Win Rate: <b>{win_rate:.1f}%</b>

<b>Financeiro:</b>
‚Ä¢ Lucro Total: ${perf['lucro_total']:.2f}
‚Ä¢ Saldo Atual: <b>${perf['saldo_atual']:.2f}</b>

üéØ <i>Estrat√©gia em execu√ß√£o</i>
        """
        
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def comando_sentimento(self, update, context):
        """Comando /sentimento"""
        sentimento = self.estado['sentimento_mercado']
        
        emoji = {
            'MUITO_POSITIVO': 'üöÄ',
            'POSITIVO': 'üìà',
            'NEUTRO': 'üìä',
            'NEGATIVO': 'üìâ',
            'MUITO_NEGATIVO': 'üîª'
        }.get(sentimento.get('sentimento_geral', 'NEUTRO'), 'üìä')
        
        mensagem = f"""
üé≠ <b>AN√ÅLISE DE SENTIMENTOS</b>

<b>Sentimento:</b> {emoji} {sentimento.get('sentimento_geral', 'N/A')}
<b>Score M√©dio:</b> {sentimento.get('score_medio', 0):.3f}
<b>Intensidade:</b> {sentimento.get('intensidade', 0):.3f}
<b>Not√≠cias:</b> {sentimento.get('total_noticias', 0)}

‚è∞ <i>Atualizado: {sentimento.get('timestamp', 'N/A')[11:19]}</i>
        """
        
        await update.message.reply_text(mensagem, parse_mode='HTML')
    
    async def iniciar_telegram_bot(self):
        """Iniciar bot do Telegram"""
        try:
            application = Application.builder().token(self.config.TELEGRAM_BOT_TOKEN).build()
            
            # Comandos
            application.add_handler(CommandHandler("start", self.comando_start))
            application.add_handler(CommandHandler("status", self.comando_status))
            application.add_handler(CommandHandler("operacoes", self.comando_operacoes))
            application.add_handler(CommandHandler("performance", self.comando_performance))
            application.add_handler(CommandHandler("sentimento", self.comando_sentimento))
            application.add_handler(CommandHandler("saldo", self.comando_saldo))
            
            # Mensagem de inicializa√ß√£o
            status_bybit = "üü¢ CONECTADO" if not self.bybit.modo_offline else "üî¥ OFFLINE"
            
            await self.enviar_mensagem(
                f"ü§ñ <b>TAVARES A EVOLU√á√ÉO</b> üî•\n\n"
                f"üí∞ <b>Status:</b> {status_bybit}\n"
                f"üéØ <b>Modo:</b> OPERA√á√ÉO REAL\n"
                f"‚ö° <b>Estrat√©gia:</b> Neural Avan√ßada\n\n"
                f"üß† <i>Sistema inicializado com sucesso</i>\n"
                f"üìä <i>Monitoramento 24/7 ativo</i>\n"
                f"üöÄ <i>Pronto para operar!</i>"
            )
            
            logger.info("ü§ñ Bot Telegram inicializado com sucesso")
            return application
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao iniciar Telegram: {e}")
            return None
    
    async def executar_continuamente(self):
        """Executar sistema continuamente"""
        logger.info("üöÄ TAVARES - INICIANDO SISTEMA PRINCIPAL")
        
        # Iniciar bot Telegram
        telegram_app = await self.iniciar_telegram_bot()
        
        if telegram_app:
            await telegram_app.initialize()
            await telegram_app.start()
            await telegram_app.updater.start_polling()
        
        # Loop principal
        while True:
            try:
                await self.executar_ciclo_trading()
                await asyncio.sleep(self.config.INTERVALO_ANALISE)
                
            except Exception as e:
                logger.error(f"üí• ERRO NO LOOP PRINCIPAL: {e}")
                await asyncio.sleep(30)  # Espera antes de retry
